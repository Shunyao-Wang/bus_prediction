[TOC]



## 快速记录

同一条线路的上下行的总站数有的是不一样的，故要分开统计

O_RUN字段官方解释是“车辆的运行状态”，而实际上观察数据过程中发现，很大一部分记录中车辆明明在正常运行，这个字段却是“0”值，说明这个字段异常很严重，不可使用。



快关门字段，很经常记录缺失，不可用（纸条上写了）



以下称一次上行/下行为一趟，一次完整上下行为一个来回



## 第一阶段：从原始记录的特征构造



###概述：构造到站记录，从原始GPS记录提取到站记录

原始记录描述：每天的原始记录独立成一个csv文件。

首先要将原始GPS记录（10s一条）转化成一条条到站记录（到站一次一条）。大题的思路是对原始记录进行排序然后遍历，然后判断一次到站后写下一条到站记录。



### 数据记录中的脏点处理：

1. 长时间停靠在重点站，说明在休息没在行驶，这种情况应当处理掉不能干扰到站记录

   经观察发现这种情况只会（保留）出现在每趟（上行或者下行）的发车之前，也即其SPEED字段长期为0且NEXTSTATION字段一直是相反趟的末站。

   处理方法：

   设置若 “row_cur记录的SPEED字段为0” & “row_cur 的NEXTSTATION字段为该趟的相反趟的末站”（但其实此时的UP字段还在上一趟中，没有改变过来，也即若此趟UP为0，在发车前的这些记录中UP还是为1的），那么continue这次for循环。

2. 司机忘按到站钮导致的记录不可用问题

   分为以下两种情况：（NEXTSTATION字段）

   - 4，4，4，5，7，8，8，8，8；不可用段站点出现一次
   - 4，4，4，8，8，8；不可用段站点直接不出现（在某两个GPS上传时间点之间一下子都按掉了）

   共同点就是，不可用站点的记录条出现次数<=1。故可使用以下判断标准排除这种情况：

   - 在第一阶段提取到站记录的时候，设置两个游标，row_next与row_cur，当next与cur的NEXTSTATION字段一样，才能对row_cur做一条到站记录，否则丢弃（否则说明该站点出现次数<=1)。

   这个算法本质就是要求某个NEXTSTATION字段取值必须要出现两次及以上才能够被提取成一次到站记录，故解决了忘按到站钮导致的数据污染问题。具有一定的健壮性，因为某站如果是正常按到站钮的话，由于两站之间的时间间隔绝对大于GPS记录间隔10s，那么NEXTSTATION字段一定会在多条记录中出现。

   ​

   另，对`4，4，4，5，7，8，8，8，8` 与`4，4，4，8，8，8`两种情况，其`4` ~ `8`之间的站点数据都是要丢弃的，但是`4` 与`8`两个站点本身的到站时间是要保留下来的，因为相当于脏记录把一趟完整的上/下行分为两段，一段是`NEXTSTATION=2`到`NEXTSTATION=4` ，一段是`NEXTSTATION=8` 到 `NEXTSTATION=30（比方说）`，故这里`4` 与 `8`分别是前段的右边界与后端的左边界，都是区间端点，故必须保留下来用于计算区间时常。

   ​

### 算法设计：

- 对25个csv文件分别处理。取某天的记录做一个dataframe

- 排序预处理：按照 “线路->车号->时间戳” 的优先级对一个文件内的记录进行排序。

- 对dataframe 设置三个游标 `row_prev` `row_cur` `row_next`进行遍历。`row_prev`与`row_next`是辅助游标，`row_cur`是焦点游标。针对三者的`NEXTSTATION`字段，

  - 当***`SPEED_cur==0 & NS_cur==final_station `*** ，continue。用于跳过公交尚未发动时产生的GPS记录。其中`final_station`字段是对应的最末站。
  - 当 ***`NS_cur!=NS_prev[①] & NS_cur==NS_next[②]`***时，对`NS_cur`做一条到站记录。①是用于判断到站，`NEXTSTATION`字段变化则说明到站；②是用于解决上述数据脏点问题中的2.问题；（从这里可以看出，当出现诸如`4,4,4,4`的序列时，我们会取第一条记录的时间，这是合理的）。也即：当cur记录前有不同站后有相同站的时候，说明要做一条到站记录了！

  ***注：***`NS_cur!=NS_prev[①]`不能改为`NS_cur!=NS_prev+1[①]`，这是为了保留区间端点，上面说到过，只要变化了（且后面有连续的此站记录）则认为到站了，不用严格=+1，这样就能照顾到中间站点司机忘按钮的情况：如果改为后者的话那么`4,4,4,8,8,8`这种情况下`8` 的到站记录就不会被提取保存下来，那么就会造成脏数据之后的后半段的到站记录序列的起始端点缺失。

  ***注意：*** 遍历过程要进行边界处理。在for中使用iterrows()生成器，对row_next进行赋值，故右边界无需处理，左边界需处理。

- ​



##第二阶段：对到站记录的清洗